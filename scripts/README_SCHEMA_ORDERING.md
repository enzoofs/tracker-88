# Schema Ordering Solution

## Problem

The original `full_schema.sql` (generated by concatenating all 39 migration files) failed when run in the Supabase SQL Editor due to dependency ordering issues:
- Triggers referenced tables that hadn't been created yet
- Functions were used before being defined
- Policies referenced tables before they existed

## Solution

Created `generate_ordered_schema.py` that:

1. **Reads** all 39 migration files in chronological order
2. **Parses** SQL into individual statements (handling dollar-quoted strings `$$...$$`)
3. **Classifies** each statement into execution phases:
   - Phase 1: Extensions
   - Phase 2: Types/Domains (e.g., `CREATE TYPE`)
   - Phase 3: Functions (including `CREATE OR REPLACE FUNCTION`)
   - Phase 4: Tables (`CREATE TABLE`)
   - Phase 5: Indexes (`CREATE INDEX`)
   - Phase 6: Triggers (`CREATE TRIGGER`)
   - Phase 7: Policies/RLS/Grants (`CREATE POLICY`, `ENABLE ROW LEVEL SECURITY`)
   - Phase 8: Other (`ALTER TABLE ADD CONSTRAINT`, `INSERT`, etc.)
4. **Reorders** statements by phase while preserving original order within each phase
5. **Wraps** everything in a single transaction (`BEGIN; ... COMMIT;`)

## Usage

```bash
# Generate the ordered schema
python scripts/generate_ordered_schema.py

# Output: scripts/full_schema.sql
# Then copy/paste into Supabase SQL Editor
```

## Results

**Input:**
- 39 migration files
- Chronological order (may have dependency issues)

**Output:**
- 1 properly ordered SQL file
- 375 total statements
- Wrapped in transaction
- Ready to run in SQL Editor

**Statement Distribution:**
```
Phase 2 - Types/Domains                 :    1 statement
Phase 3 - Functions                     :   24 statements
Phase 4 - Tables                        :   19 statements
Phase 5 - Indexes                       :   25 statements
Phase 6 - Triggers                      :   21 statements
Phase 7 - Policies/RLS/Grants           :  238 statements
Phase 8 - Other (ALTER TABLE, etc.)     :   47 statements
```

## Key Implementation Details

### SQL Statement Splitting

The parser handles:
- **Dollar-quoted strings** (`$$...$$`, `$function$...$function$`)
  - Tracks opening/closing tags to avoid splitting on semicolons inside function bodies
- **Block comments** (`/* ... */`)
- **Multi-line statements**
- **Pure comment blocks** (excluded from output)

### Classification Logic

Each statement is classified by its first significant SQL keyword:
```python
# Examples
'CREATE EXTENSION'           → Phase 1
'CREATE TYPE'                → Phase 2
'CREATE OR REPLACE FUNCTION' → Phase 3
'CREATE TABLE'               → Phase 4
'CREATE INDEX'               → Phase 5
'CREATE TRIGGER'             → Phase 6
'CREATE POLICY'              → Phase 7
'ALTER TABLE ... RLS'        → Phase 7
'ALTER TABLE ADD CONSTRAINT' → Phase 8
'INSERT INTO'                → Phase 8
```

### Ordering Strategy

Within each phase, statements maintain their original chronological order from the migration files. This ensures that:
- Functions defined in earlier migrations appear before redefinitions
- Table alterations happen in the correct sequence
- Data insertions respect foreign key constraints

## Limitations

- Does not detect circular dependencies (assumes migrations are correct)
- Does not optimize within phases (e.g., reordering tables by FK dependencies)
- Does not handle `DROP` statements specially (they stay in their phase)
- Transaction wrapping assumes all statements are idempotent or can be retried

## Maintenance

To regenerate after adding new migrations:
```bash
python scripts/generate_ordered_schema.py
```

The script automatically discovers all `.sql` files in `supabase/migrations/` and processes them in alphabetical (chronological) order.
